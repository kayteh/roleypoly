// @flow
/**
 * Flowtype definitions for eris
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Katalina T.](http://twitter.com/kayteh)
 * Repo: http://github.com/kayteh/roleypoly
 */

declare module 'eris' {
  import type EventEmitter from 'events'

  import type { Readable as ReadableStream } from 'stream'

  declare interface JSONCache {
    [s: string]: any;
  }
  declare interface SimpleJSON {
    toJSON(simple?: boolean): JSONCache;
  }
  declare interface NestedJSON {
    toJSON(arg?: any, cache?: Array<string | any>): JSONCache;
  }
  declare type TextableChannel = TextChannel | PrivateChannel | GroupChannel;
  declare type AnyChannel =
    | TextChannel
    | VoiceChannel
    | CategoryChannel
    | PrivateChannel
    | GroupChannel;
  declare type AnyGuildChannel = TextChannel | VoiceChannel | CategoryChannel;
  declare interface CreateInviteOptions {
    maxAge?: number;
    maxUses?: number;
    temporary?: boolean;
  }
  declare interface Invitable {
    getInvites(): Promise<Invite[]>;
    createInvite(
      options?: CreateInviteOptions,
      reason?: string
    ): Promise<Invite>;
  }
  declare interface Textable {
    lastMessageID: string;
    messages: Collection<Message>;
    sendTyping(): Promise<void>;
    getMessage(messageID: string): Promise<Message>;
    getMessages(
      limit?: number,
      before?: string,
      after?: string,
      around?: string
    ): Promise<Message[]>;
    getPins(): Promise<Message[]>;
    createMessage(
      content: MessageContent,
      file?: MessageFile
    ): Promise<Message>;
    editMessage(messageID: string, content: MessageContent): Promise<Message>;
    pinMessage(messageID: string): Promise<void>;
    unpinMessage(messageID: string): Promise<void>;
    getMessageReaction(
      messageID: string,
      reaction: string,
      limit?: number,
      before?: string,
      after?: string
    ): Promise<User[]>;
    addMessageReaction(
      messageID: string,
      reaction: string,
      userID?: string
    ): Promise<void>;
    removeMessageReaction(
      messageID: string,
      reaction: string,
      userID?: string
    ): Promise<void>;
    removeMessageReactions(messageID: string): Promise<void>;
    deleteMessage(messageID: string, reason?: string): Promise<void>;
    unsendMessage(messageID: string): Promise<void>;
  }
  declare interface OldCall {
    participants: string[];
    endedTimestamp?: number;
    ringing: string[];
    region: string;
    unavailable: boolean;
  }
  declare interface OldChannel {
    name: string;
    position: string;
    topic?: string;
    bitrate?: number;
    permissionOverwrites: Collection<PermissionOverwrite>;
  }
  declare type FriendSuggestionReasons = Array<{
    type: number,
    platform_type: string,
    name: string
  }>;
  declare interface MemberPartial {
    id: string;
    user: User;
  }
  declare interface OldPresence {
    status: string;
    game?: {
      name: string,
      type: number,
      url?: string
    };
  }
  declare interface OldVoiceState {
    mute: boolean;
    deaf: boolean;
    selfMute: boolean;
    selfDeaf: boolean;
  }
  declare interface Emittable {
    on(event: string, listener: Function): *;
    on(event: "ready" | "disconnect", listener: () => void): *;
    on(
      event: "callCreate" | "callRing" | "callDelete",
      listener: (call: Call) => void
    ): *;
    on(
      event: "callUpdate",
      listener: (call: Call, oldCall: OldCall) => void
    ): *;
    on(
      event: "channelCreate" | "channelDelete",
      listener: (channel: AnyChannel) => void
    ): *;
    on(
      event: "channelPinUpdate",
      listener: (
        channel: TextableChannel,
        timestamp: number,
        oldTimestamp: number
      ) => void
    ): *;
    on(
      event: "channelRecipientAdd" | "channelRecipientRemove",
      listener: (channel: GroupChannel, user: User) => void
    ): *;
    on(
      event: "channelUpdate",
      listener: (channel: AnyChannel, oldChannel: OldChannel) => void
    ): *;
    on(
      event: "friendSuggestionCreate",
      listener: (user: User, reasons: FriendSuggestionReasons) => void
    ): *;
    on(event: "friendSuggestionDelete", listener: (user: User) => void): *;
    on(
      event: "guildAvailable" | "guildBanAdd" | "guildBanRemove",
      listener: (guild: Guild, user: User) => void
    ): *;
    on(
      event: "guildDelete" | "guildUnavailable" | "guildCreate",
      listener: (guild: Guild) => void
    ): *;
    on(
      event: "guildEmojisUpdate",
      listener: (guild: Guild, emojis: Emoji[], oldEmojis: Emoji[]) => void
    ): *;
    on(
      event: "guildMemberAdd",
      listener: (guild: Guild, member: Member) => void
    ): *;
    on(
      event: "guildMemberChunk",
      listener: (guild: Guild, members: Member[]) => void
    ): *;
    on(
      event: "guildMemberRemove",
      listener: (guild: Guild, member: Member | MemberPartial) => void
    ): *;
    on(
      event: "guildMemberUpdate",
      listener: (
        guild: Guild,
        member: Member,
        oldMember: {
          roles: string[],
          nick?: string
        }
      ) => void
    ): *;
    on(
      event: "guildRoleCreate" | "guildRoleDelete",
      listener: (guild: Guild, role: Role) => void
    ): *;
    on(
      event: "guildRoleUpdate",
      listener: (guild: Guild, role: Role, oldRole: RoleOptions) => void
    ): *;
    on(
      event: "guildUpdate",
      listener: (guild: Guild, oldGuild: GuildOptions) => void
    ): *;
    on(event: "hello", listener: (trace: string[], id: number) => void): *;
    on(event: "messageCreate", listener: (message: Message) => void): *;
    on(
      event: "messageDelete" | "messageReactionRemoveAll",
      listener: (message: PossiblyUncachedMessage) => void
    ): *;
    on(
      event: "messageDeleteBulk",
      listener: (messages: PossiblyUncachedMessage[]) => void
    ): *;
    on(
      event: "messageReactionAdd" | "messageReactionRemove",
      listener: (
        message: PossiblyUncachedMessage,
        emoji: Emoji,
        userID: string
      ) => void
    ): *;
    on(
      event: "messageUpdate",
      listener: (
        message: Message,
        oldMessage?: {
          attachments: Attachment[],
          embeds: Embed[],
          content: string,
          editedTimestamp?: number,
          mentionedBy?: any,
          tts: boolean,
          mentions: string[],
          roleMentions: string[],
          channelMentions: string[]
        }
      ) => void
    ): *;
    on(
      event: "presenceUpdate",
      listener: (
        other: Member | Relationship,
        oldPresence?: OldPresence
      ) => void
    ): *;
    on(
      event: "rawWS" | "unknown",
      listener: (packet: RawPacket, id: number) => void
    ): *;
    on(
      event: "relationshipAdd" | "relationshipRemove",
      listener: (relationship: Relationship) => void
    ): *;
    on(
      event: "relationshipUpdate",
      listener: (
        relationship: Relationship,
        oldRelationship: {
          type: number
        }
      ) => void
    ): *;
    on(
      event: "shardPreReady" | "connect",
      listener: (id: number) => void
    ): *;
    on(
      event: "typingStart",
      listener: (channel: TextableChannel, user: User) => void
    ): *;
    on(
      event: "unavailableGuildCreate",
      listener: (guild: UnavailableGuild) => void
    ): *;
    on(
      event: "userUpdate",
      listener: (
        user: User,
        oldUser: {
          username: string,
          discriminator: string,
          avatar?: string
        }
      ) => void
    ): *;
    on(
      event: "voiceChannelJoin",
      listener: (member: Member, newChannel: VoiceChannel) => void
    ): *;
    on(
      event: "voiceChannelLeave",
      listener: (member: Member, oldChannel: VoiceChannel) => void
    ): *;
    on(
      event: "voiceChannelSwitch",
      listener: (
        member: Member,
        newChannel: VoiceChannel,
        oldChannel: VoiceChannel
      ) => void
    ): *;
    on(
      event: "voiceStateUpdate",
      listener: (member: Member, oldState: OldVoiceState) => void
    ): *;
    on(
      event: "warn" | "debug",
      listener: (message: string, id: number) => void
    ): *;
  }
  declare interface IConstants {
    DefaultAvatarHashes: string[];
    ImageFormats: string[];
    GatewayOPCodes: {
      [key: string]: number
    };
    GATEWAY_VERSION: number;
    Permissions: {
      [key: string]: number
    };
    VoiceOPCodes: {
      [key: string]: number
    };
    SystemJoinMessages: string[];
    AuditLogActions: {
      [key: string]: number
    };
  }
  declare export var Constants: IConstants;
  declare interface WebhookPayload {
    content?: string;
    file?:
      | {
          file: Buffer,
          name: string
        }
      | Array<{
          file: Buffer,
          name: string
        }>;
    embeds?: EmbedOptions[];
    username?: string;
    avatarURL?: string;
    tts?: boolean;
    wait?: boolean;
    disableEveryone?: boolean;
  }
  declare interface EmbedBase {
    title?: string;
    description?: string;
    url?: string;
    timestamp?: string;
    color?: number;
    footer?: {
      text: string,
      icon_url?: string,
      proxy_icon_url?: string
    };
    image?: {
      url?: string,
      proxy_url?: string,
      height?: number,
      width?: number
    };
    thumbnail?: {
      url?: string,
      proxy_url?: string,
      height?: number,
      width?: number
    };
    video?: {
      url: string,
      height?: number,
      width?: number
    };
    provider?: {
      name: string,
      url?: string
    };
    fields?: Array<{
      name?: string,
      value?: string,
      inline?: boolean
    }>;
    author?: {
      name: string,
      url?: string,
      icon_url?: string,
      proxy_icon_url?: string
    };
  }
  declare type Embed = {
    type: string
  } & EmbedBase;
  declare type EmbedOptions = {
    type?: string
  } & EmbedBase;
  declare interface Webhook {
    name: string;
    channel_id: string;
    token: string;
    avatar?: string;
    guild_id: string;
    id: string;
    user: {
      username: string,
      discriminator: string,
      id: string,
      avatar?: string
    };
  }
  declare interface GuildEmbed {
    channel_id?: string;
    enabled: boolean;
  }
  declare interface Attachment {
    url: string;
    proxy_url: string;
    size: number;
    id: string;
    filename: string;
  }
  declare interface VoiceRegion {
    name: string;
    deprecated: boolean;
    custom: boolean;
    vip: boolean;
    optimal: boolean;
    id: string;
  }
  declare interface UserSettings {
    theme: string;
    status: string;
    show_current_game: boolean;
    restricted_guilds: string[];
    render_reactions: boolean;
    render_embeds: boolean;
    message_display_compact: boolean;
    locale: string;
    inline_embed_media: boolean;
    inline_attachment_media: boolean;
    guild_positions: string[];
    friend_source_flags: {
      all: boolean
    };
    explicit_content_filter: number;
    enable_tts_command: boolean;
    developer_mode: boolean;
    detect_platform_accounts: boolean;
    default_guilds_restricted: boolean;
    convert_emojis: boolean;
    afk_timeout: number;
  }
  declare interface GuildSettings {
    suppress_everyone: boolean;
    muted: boolean;
    mobile_push: boolean;
    message_notifications: number;
    guild_id: string;
    channel_override: Array<{
      muted: boolean,
      message_notifications: number,
      channel_id: string
    }>;
  }
  declare interface UserProfile {
    premium_since?: number;
    mutual_guilds: Array<{
      nick?: string,
      id: string
    }>;
    user: {
      username: string,
      discriminator: string,
      flags: number,
      id: string,
      avatar?: string
    };
    connected_accounts: Array<{
      verified: boolean,
      type: string,
      id: string,
      name: string
    }>;
  }
  declare interface Connection {
    verified: boolean;
    revoked: boolean;
    integrations: any[];
    visibility: number;
    friend_sync: boolean;
    type: string;
    id: string;
    name: string;
  }
  declare interface GuildAuditLog {
    users: User[];
    entries: GuildAuditLogEntry[];
  }
  declare interface BaseData {
    id: string;
    [key: string]: {};
  }
  declare type MessageContent =
    | string
    | {
        content?: string,
        tts?: boolean,
        disableEveryone?: boolean,
        embed?: EmbedOptions
      };
  declare interface MessageFile {
    file: Buffer | string;
    name: string;
  }
  declare interface EmojiBase {
    name: string;
    icon?: string;
  }
  declare type EmojiOptions = {
    roles?: string[]
  } & EmojiBase;
  declare type Emoji = {
    roles: string[]
  } & EmojiBase;
  declare interface IntegrationOptions {
    expireBehavior: string;
    expireGracePeriod: string;
    enableEmoticons: string;
  }
  declare interface GuildOptions {
    name?: string;
    region?: string;
    icon?: string;
    verificationLevel?: number;
    defaultNotifications?: number;
    afkChannelID?: string;
    afkTimeout?: number;
    ownerID?: string;
    splash?: string;
  }
  declare interface MemberOptions {
    roles?: string[];
    nick?: string;
    mute?: boolean;
    deaf?: boolean;
    channelID?: string;
  }
  declare interface RoleOptions {
    name?: string;
    permissions?: number;
    color?: number;
    hoist?: boolean;
    mentionable?: boolean;
  }
  declare interface GamePresence {
    name: string;
    type?: number;
    url?: string;
  }
  declare interface SearchOptions {
    sortBy?: string;
    sortOrder?: string;
    content?: string;
    authorID?: string;
    minID?: string;
    maxID?: string;
    limit?: number;
    offset?: number;
    contextSize?: number;
    has?: string;
    embedProviders?: string;
    embedTypes?: string;
    attachmentExtensions?: string;
    attachmentFilename?: string;
    channelIDs: string[];
  }
  declare interface SearchResults {
    totalResults: number;
    results: Array<
      Array<
        Message & {
          hit?: boolean
        }
      >
    >;
  }
  declare interface VoiceResourceOptions {
    inlineVolume?: boolean;
    voiceDataTimeout?: number;
    inputArgs?: string[];
    encoderArgs?: string[];
    format?: string;
    frameDuration?: number;
    frameSize?: number;
    sampleRate?: number;
  }
  declare type PossiblyUncachedMessage =
    | Message
    | {
        id: string,
        channel: TextableChannel
      };
  declare interface RawPacket {
    op: number;
    t?: string;
    d?: any;
    s?: number;
  }
  declare type ClientOptions = $Shape<{
    autoreconnect: boolean;
    compress: boolean;
    connectionTimeout: number;
    disableEvents: {
      [s: string]: boolean
    };
    disableEveryone: boolean;
    firstShardID: number;
    getAllUsers: boolean;
    guildCreateTimeout: number;
    largeThreshold: number;
    lastShardID: number;
    maxShards: number | "auto";
    messageLimit: number;
    opusOnly: boolean;
    restMode: boolean;
    seedVoiceConnections: boolean;
    defaultImageFormat: string;
    defaultImageSize: number;
    ws: any;
    latencyThreshold: number;
  }>
  declare type CommandClientOptions = $Shape<{
    defaultHelpCommand: boolean;
    description: string;
    ignoreBots: boolean;
    ignoreSelf: boolean;
    name: string;
    owner: string;
    prefix: string | string[];
    defaultCommandOptions: CommandOptions;
  }>
  declare interface Hooks {
    preCommand?: (msg: Message, args: string[]) => void;
    postCheck?: (msg: Message, args: string[], checksPassed: boolean) => void;
    postExecution?: (
      msg: Message,
      args: string[],
      executionSuccess: boolean
    ) => void;
    postCommand?: (msg: Message, args: string[], sent?: Message) => void;
  }
  declare type GenericCheckFunction<T> = (msg: Message) => T;
  declare type CommandOptions = $Shape<{
    aliases?: string[];
    caseInsensitive?: boolean;
    deleteCommand?: boolean;
    argsRequired?: boolean;
    guildOnly?: boolean;
    dmOnly?: boolean;
    description?: string;
    fullDescription?: string;
    usage?: string;
    hooks?: Hooks;
    requirements?: {
      userIDs?: string[] | GenericCheckFunction<string[]>,
      roleIDs?: string[] | GenericCheckFunction<string[]>,
      roleNames?: string[] | GenericCheckFunction<string[]>,
      permissions?:
        | {
            [s: string]: boolean
          }
        | GenericCheckFunction<{
            [s: string]: boolean
          }>,
      custom?: GenericCheckFunction<void>
    };
    cooldown?: number;
    cooldownExclusions?: {
      userIDs?: string[],
      guildIDs?: string[],
      channelIDs?: string[]
    };
    restartCooldown?: boolean;
    cooldownReturns?: number;
    cooldownMessage?: string | GenericCheckFunction<string>;
    invalidUsageMessage?: string | GenericCheckFunction<string>;
    permissionMessage?: string | GenericCheckFunction<string>;
    errorMessage?: string | GenericCheckFunction<string>;
    reactionButtons?: Array<{
      emoji: string,
      type: string,
      response: CommandGenerator
    }>;
    reactionButtonTimeout?: number;
    defaultSubcommandOptions?: CommandOptions;
    hidden?: boolean;
  }>
  declare type CommandGeneratorFunction = (
    msg: Message,
    args: string[]
  ) => Promise<MessageContent> | Promise<void> | MessageContent | void;
  declare type CommandGenerator =
    | CommandGeneratorFunction
    | MessageContent
    | MessageContent[]
    | CommandGeneratorFunction[];
  declare export class ShardManager extends Collection<Shard> {
    constructor(client: Client): *;
    connect(shard: Shard): void;
    spawn(id: number): void;
    toJSON(): string;
  }
  declare export default class Client extends events$EventEmitter implements SimpleJSON, Emittable {
    token: string;
    gatewayURL: string;
    bot: boolean;
    options: ClientOptions;
    channelGuildMap: {
      [s: string]: string
    };
    shards: ShardManager;
    guilds: Collection<Guild>;
    privateChannelMap: {
      [s: string]: string
    };
    privateChannels: Collection<PrivateChannel>;
    groupChannels: Collection<GroupChannel>;
    voiceConnections: Collection<VoiceConnection>;
    guildShardMap: {
      [s: string]: number
    };
    startTime: number;
    unavailableGuilds: Collection<UnavailableGuild>;
    uptime: number;
    user: ExtendedUser;
    users: Collection<User>;
    relationships: Collection<Relationship>;
    userGuildSettings: {
      [s: string]: GuildSettings
    };
    userSettings: UserSettings;
    notes: {
      [s: string]: string
    };
    constructor(token: string, options?: ClientOptions): *;
    connect(): Promise<void>;
    getGateway(): Promise<string>;
    getBotGateway(): Promise<{
      url: string,
      shards: number
    }>;
    disconnect(options: {
      reconnect: boolean
    }): void;
    joinVoiceChannel(
      channelID: string,
      options?: {
        shared?: boolean,
        opusOnly?: boolean
      }
    ): Promise<VoiceConnection>;
    leaveVoiceChannel(channelID: string): void;
    closeVoiceConnection(guildID: string): void;
    editAFK(afk: boolean): void;
    editStatus(status?: string, game?: GamePresence): void;
    getChannel(channelID: string): AnyChannel;
    createChannel(
      guildID: string,
      name: string,
      type?: number,
      reason?: string,
      parentID?: string
    ): Promise<AnyGuildChannel>;
    editChannel(
      channelID: string,
      options: {
        name?: string,
        icon?: string,
        ownerID?: string,
        topic?: string,
        bitrate?: number,
        userLimit?: number,
        nsfw?: boolean,
        parentID?: string
      },
      reason?: string
    ): Promise<GroupChannel | AnyGuildChannel>;
    editChannelPosition(channelID: string, position: number): Promise<void>;
    deleteChannel(channelID: string, reason?: string): Promise<void>;
    sendChannelTyping(channelID: string): Promise<void>;
    editChannelPermission(
      channelID: string,
      overwriteID: string,
      allow: number,
      deny: number,
      type: string,
      reason?: string
    ): Promise<void>;
    deleteChannelPermission(
      channelID: string,
      overwriteID: string,
      reason?: string
    ): Promise<void>;
    getChannelInvites(channelID: string): Promise<Invite[]>;
    createChannelInvite(
      channelID: string,
      options?: {
        maxAge?: number,
        maxUses?: number,
        temporary?: boolean,
        unique?: boolean
      },
      reason?: string
    ): Promise<Invite>;
    getChannelWebhooks(channelID: string): Promise<Webhook[]>;
    getWebhook(webhookID: string, token?: string): Promise<Webhook>;
    createChannelWebhook(
      channelID: string,
      options: {
        name: string,
        avatar: string
      },
      reason?: string
    ): Promise<Webhook>;
    editWebhook(
      webhookID: string,
      options: {
        name?: string,
        avatar?: string
      },
      token?: string,
      reason?: string
    ): Promise<Webhook>;
    executeWebhook(
      webhookID: string,
      token: string,
      options: WebhookPayload
    ): Promise<void>;
    executeSlackWebhook(
      webhookID: string,
      token: string,
      options?: {
        wait?: boolean
      }
    ): Promise<void>;
    deleteWebhook(
      webhookID: string,
      token?: string,
      reason?: string
    ): Promise<void>;
    getGuildWebhooks(guildID: string): Promise<Webhook[]>;
    getGuildAuditLogs(
      guildID: string,
      limit?: number,
      before?: string,
      actionType?: number
    ): Promise<GuildAuditLog>;
    createGuildEmoji(
      guildID: string,
      options: EmojiOptions,
      reason?: string
    ): Promise<Emoji>;
    editGuildEmoji(
      guildID: string,
      emojiID: string,
      options: {
        name?: string,
        roles?: string[]
      },
      reason?: string
    ): Promise<Emoji>;
    deleteGuildEmoji(
      guildID: string,
      emojiID: string,
      reason?: string
    ): Promise<void>;
    createRole(
      guildID: string,
      options?: RoleOptions,
      reason?: string
    ): Promise<Role>;
    editRole(
      guildID: string,
      roleID: string,
      options: RoleOptions,
      reason?: string
    ): Promise<Role>;
    editRolePosition(
      guildID: string,
      roleID: string,
      position: number
    ): Promise<void>;
    deleteRole(guildID: string, roleID: string, reason?: string): Promise<void>;
    getPruneCount(guildID: string, days: number): Promise<number>;
    pruneMembers(
      guildID: string,
      days: number,
      reason?: string
    ): Promise<number>;
    getVoiceRegions(guildID: string): Promise<VoiceRegion[]>;
    getInvite(inviteID: string, withCounts?: boolean): Promise<Invite>;
    acceptInvite(inviteID: string): Promise<Invite>;
    deleteInvite(inviteID: string, reason?: string): Promise<void>;
    getSelf(): Promise<ExtendedUser>;
    editSelf(options: {
      username?: string,
      avatar?: string
    }): Promise<ExtendedUser>;
    getDMChannel(userID: string): Promise<PrivateChannel>;
    createGroupChannel(userIDs: string[]): Promise<GroupChannel>;
    getMessage(channelID: string, messageID: string): Promise<Message>;
    getMessages(
      channelID: string,
      limit?: number,
      before?: string,
      after?: string,
      around?: string
    ): Promise<Message[]>;
    getPins(channelID: string): Promise<Message[]>;
    createMessage(
      channelID: string,
      content: MessageContent,
      file?: MessageFile
    ): Promise<Message>;
    editMessage(
      channelID: string,
      messageID: string,
      content: MessageContent
    ): Promise<Message>;
    pinMessage(channelID: string, messageID: string): Promise<void>;
    unpinMessage(channelID: string, messageID: string): Promise<void>;
    getMessageReaction(
      channelID: string,
      messageID: string,
      reaction: string,
      limit?: number,
      before?: string,
      after?: string
    ): Promise<User[]>;
    addMessageReaction(
      channelID: string,
      messageID: string,
      reaction: string,
      userID?: string
    ): Promise<void>;
    removeMessageReaction(
      channelID: string,
      messageID: string,
      reaction: string,
      userID?: string
    ): Promise<void>;
    removeMessageReactions(channelID: string, messageID: string): Promise<void>;
    deleteMessage(
      channelID: string,
      messageID: string,
      reason?: string
    ): Promise<void>;
    deleteMessages(
      channelID: string,
      messageIDs: string[],
      reason?: string
    ): Promise<void>;
    purgeChannel(
      channelID: string,
      limit?: number,
      filter?: (m: Message) => boolean,
      before?: string,
      after?: string
    ): Promise<number>;
    getGuildEmbed(guildID: string): Promise<GuildEmbed>;
    getGuildIntegrations(guildID: string): Promise<GuildIntegration[]>;
    editGuildIntegration(
      guildID: string,
      integrationID: string,
      options: IntegrationOptions
    ): Promise<void>;
    deleteGuildIntegration(
      guildID: string,
      integrationID: string
    ): Promise<void>;
    syncGuildIntegration(guildID: string, integrationID: string): Promise<void>;
    getGuildInvites(guildID: string): Promise<Invite[]>;
    banGuildMember(
      guildID: string,
      userID: string,
      deleteMessageDays?: number,
      reason?: string
    ): Promise<void>;
    unbanGuildMember(
      guildID: string,
      userID: string,
      reason?: string
    ): Promise<void>;
    createGuild(name: string, region: string, icon?: string): Promise<Guild>;
    editGuild(
      guildID: string,
      options: GuildOptions,
      reason?: string
    ): Promise<Guild>;
    getGuildBans(
      guildID: string
    ): Promise<
      Array<{
        reason?: string,
        user: User
      }>
    >;
    editGuildMember(
      guildID: string,
      memberID: string,
      options: MemberOptions,
      reason?: string
    ): Promise<void>;
    addGuildMemberRole(
      guildID: string,
      memberID: string,
      roleID: string,
      reason?: string
    ): Promise<void>;
    removeGuildMemberRole(
      guildID: string,
      memberID: string,
      roleID: string,
      reason?: string
    ): Promise<void>;
    editNickname(guildID: string, nick: string, reason?: string): Promise<void>;
    kickGuildMember(
      guildID: string,
      userID: string,
      reason?: string
    ): Promise<void>;
    deleteGuild(guildID: string): Promise<void>;
    leaveGuild(guildID: string): Promise<void>;
    getOAuthApplication(
      appID?: string
    ): Promise<{
      description: string,
      name: string,
      owner: {
        username: string,
        discriminator: string,
        id: string,
        avatar?: string
      },
      bot_public: boolean,
      bot_require_code_grant: boolean,
      id: string,
      icon?: string
    }>;
    addRelationship(userID: string, block?: boolean): Promise<void>;
    removeRelationship(userID: string): Promise<void>;
    addGroupRecipient(groupID: string, userID: string): Promise<void>;
    removeGroupRecipient(groupID: string, userID: string): Promise<void>;
    getUserProfile(userID: string): Promise<UserProfile>;
    editUserNote(userID: string, note: string): Promise<void>;
    deleteUserNote(userID: string): Promise<void>;
    getSelfConnections(): Promise<Connection[]>;
    editSelfConnection(
      platform: string,
      id: string,
      data: {
        friendSync: boolean,
        visibility: number
      }
    ): Promise<Connection>;
    deleteSelfConnection(platform: string, id: string): Promise<void>;
    getSelfSettings(): Promise<UserSettings>;
    editSelfSettings(data: UserSettings): Promise<UserSettings>;
    getSelfMFACodes(
      password: string,
      regenerate?: boolean
    ): Promise<{
      backup_codes: Array<{
        code: string,
        consumed: boolean
      }>
    }>;
    enableSelfMFATOTP(
      secret: string,
      code: string
    ): Promise<{
      token: string,
      backup_codes: Array<{
        code: string,
        consumed: boolean
      }>
    }>;
    disableSelfMFATOTP(
      code: string
    ): Promise<{
      token: string
    }>;
    getSelfBilling(): Promise<{
      premium_subscription?: {
        status: number,
        ended_at?: string,
        canceled_at?: string,
        created_at: string,
        current_period_end?: string,
        current_period_start?: string,
        plan: string
      },
      payment_source?: {
        type: string,
        brand: string,
        invalid: boolean,
        last_4: number,
        expires_year: number,
        expires_month: number
      },
      payment_gateway?: string
    }>;
    getSelfPayments(): Promise<
      Array<{
        status: number,
        amount_refunded: number,
        description: string,
        created_at: string,
        currency: string,
        amount: number
      }>
    >;
    addSelfPremiumSubscription(token: string, plan: string): Promise<void>;
    deleteSelfPremiumSubscription(): Promise<void>;
    getRESTChannel(channelID: string): Promise<AnyChannel>;
    getRESTGuild(guildID: string): Promise<Guild>;
    getRESTGuilds(
      limit?: number,
      before?: string,
      after?: string
    ): Promise<Guild[]>;
    getRESTGuildChannels(guildID: string): Promise<AnyGuildChannel[]>;
    getRESTGuildEmojis(guildID: string): Promise<Emoji[]>;
    getRESTGuildEmoji(guildID: string, emojiID: string): Promise<Emoji>;
    getRESTGuildMembers(
      guildID: string,
      limit?: number,
      after?: string
    ): Promise<Member[]>;
    getRESTGuildMember(guildID: string, memberID: string): Promise<Member>;
    getRESTGuildRoles(guildID: string): Promise<Role[]>;
    getRESTUser(userID: string): Promise<User>;
    searchChannelMessages(
      channelID: string,
      query: SearchOptions
    ): Promise<SearchResults>;
    searchGuildMessages(
      guildID: string,
      query: SearchOptions
    ): Promise<SearchResults>;
    on(event: string, listener: Function): *;
    on(event: "ready" | "disconnect", listener: () => void): *;
    on(
      event: "callCreate" | "callRing" | "callDelete",
      listener: (call: Call) => void
    ): *;
    on(
      event: "callUpdate",
      listener: (call: Call, oldCall: OldCall) => void
    ): *;
    on(
      event: "channelCreate" | "channelDelete",
      listener: (channel: AnyChannel) => void
    ): *;
    on(
      event: "channelPinUpdate",
      listener: (
        channel: TextableChannel,
        timestamp: number,
        oldTimestamp: number
      ) => void
    ): *;
    on(
      event: "channelRecipientAdd" | "channelRecipientRemove",
      listener: (channel: GroupChannel, user: User) => void
    ): *;
    on(
      event: "channelUpdate",
      listener: (channel: AnyChannel, oldChannel: OldChannel) => void
    ): *;
    on(
      event: "friendSuggestionCreate",
      listener: (user: User, reasons: FriendSuggestionReasons) => void
    ): *;
    on(event: "friendSuggestionDelete", listener: (user: User) => void): *;
    on(
      event: "guildAvailable" | "guildBanAdd" | "guildBanRemove",
      listener: (guild: Guild, user: User) => void
    ): *;
    on(
      event: "guildDelete" | "guildUnavailable" | "guildCreate",
      listener: (guild: Guild) => void
    ): *;
    on(
      event: "guildEmojisUpdate",
      listener: (guild: Guild, emojis: Emoji[], oldEmojis: Emoji[]) => void
    ): *;
    on(
      event: "guildMemberAdd",
      listener: (guild: Guild, member: Member) => void
    ): *;
    on(
      event: "guildMemberChunk",
      listener: (guild: Guild, members: Member[]) => void
    ): *;
    on(
      event: "guildMemberRemove",
      listener: (guild: Guild, member: Member | MemberPartial) => void
    ): *;
    on(
      event: "guildMemberUpdate",
      listener: (
        guild: Guild,
        member: Member,
        oldMember: {
          roles: string[],
          nick?: string
        }
      ) => void
    ): *;
    on(
      event: "guildRoleCreate" | "guildRoleDelete",
      listener: (guild: Guild, role: Role) => void
    ): *;
    on(
      event: "guildRoleUpdate",
      listener: (guild: Guild, role: Role, oldRole: RoleOptions) => void
    ): *;
    on(
      event: "guildUpdate",
      listener: (guild: Guild, oldGuild: GuildOptions) => void
    ): *;
    on(event: "hello", listener: (trace: string[], id: number) => void): *;
    on(event: "messageCreate", listener: (message: Message) => void): *;
    on(
      event: "messageDelete" | "messageReactionRemoveAll",
      listener: (message: PossiblyUncachedMessage) => void
    ): *;
    on(
      event: "messageDeleteBulk",
      listener: (messages: PossiblyUncachedMessage[]) => void
    ): *;
    on(
      event: "messageReactionAdd" | "messageReactionRemove",
      listener: (
        message: PossiblyUncachedMessage,
        emoji: Emoji,
        userID: string
      ) => void
    ): *;
    on(
      event: "messageUpdate",
      listener: (
        message: Message,
        oldMessage?: {
          attachments: Attachment[],
          embeds: Embed[],
          content: string,
          editedTimestamp?: number,
          mentionedBy?: any,
          tts: boolean,
          mentions: string[],
          roleMentions: string[],
          channelMentions: string[]
        }
      ) => void
    ): *;
    on(
      event: "presenceUpdate",
      listener: (
        other: Member | Relationship,
        oldPresence?: OldPresence
      ) => void
    ): *;
    on(
      event: "rawWS" | "unknown",
      listener: (packet: RawPacket, id: number) => void
    ): *;
    on(
      event: "relationshipAdd" | "relationshipRemove",
      listener: (relationship: Relationship) => void
    ): *;
    on(
      event: "relationshipUpdate",
      listener: (
        relationship: Relationship,
        oldRelationship: {
          type: number
        }
      ) => void
    ): *;
    on(
      event: "typingStart",
      listener: (channel: TextableChannel, user: User) => void
    ): *;
    on(
      event: "unavailableGuildCreate",
      listener: (guild: UnavailableGuild) => void
    ): *;
    on(
      event: "userUpdate",
      listener: (
        user: User,
        oldUser: {
          username: string,
          discriminator: string,
          avatar?: string
        }
      ) => void
    ): *;
    on(
      event: "voiceChannelJoin",
      listener: (member: Member, newChannel: VoiceChannel) => void
    ): *;
    on(
      event: "voiceChannelLeave",
      listener: (member: Member, oldChannel: VoiceChannel) => void
    ): *;
    on(
      event: "voiceChannelSwitch",
      listener: (
        member: Member,
        newChannel: VoiceChannel,
        oldChannel: VoiceChannel
      ) => void
    ): *;
    on(
      event: "voiceStateUpdate",
      listener: (member: Member, oldState: OldVoiceState) => void
    ): *;
    on(
      event: "warn" | "debug",
      listener: (message: string, id: number) => void
    ): *;
    on(
      event: "shardDisconnect" | "error" | "shardPreReady" | "connect",
      listener: (err: Error, id: number) => void
    ): *;
    on(
      event: "shardReady" | "shardResume",
      listener: (id: number) => void
    ): *;
    toJSON(simple?: boolean): JSONCache;
  }
  declare export class VoiceConnection extends events$EventEmitter implements SimpleJSON {
    id: string;
    channelID: string;
    connecting: boolean;
    ready: boolean;
    playing: boolean;
    paused: boolean;
    volume: number;
    current: {
      startTime: number,
      playTime: number,
      pausedTimestamp?: number,
      pausedTime?: number,
      options: VoiceResourceOptions
    };
    constructor(
      id: string,
      options?: {
        shard?: Shard,
        shared?: boolean,
        opusOnly?: boolean
      }
    ): *;
    pause(): void;
    play(
      resource: ReadableStream | string,
      options?: VoiceResourceOptions
    ): void;
    receive(type: string): VoiceDataStream;
    resume(): void;
    setVolume(volume: number): void;
    stopPlaying(): void;
    switchChannel(channelID: string): void;
    updateVoiceState(selfMute: boolean, selfDeaf: boolean): void;
    on(event: "debug" | "warn", listener: (message: string) => void): *;
    on(event: "error" | "disconnect", listener: (err: Error) => void): *;
    on(event: "pong", listener: (latency: number) => void): *;
    on(event: "speakingStart", listener: (userID: string) => void): *;
    on(event: "end", listener: () => void): *;
    on(event: string, listener: (e: mixed, ...args: Array<any>) => void): *;
    toJSON(simple?: boolean): JSONCache;
  }
  declare export class SharedStream extends events$EventEmitter {
    playing: boolean;
    ended: boolean;
    volume: number;
    speaking: boolean;
    current: {
      startTime: number,
      playTime: number,
      pausedTimestamp?: number,
      pausedTime?: number,
      options: VoiceResourceOptions
    };
    add(connection: VoiceConnection): void;
    play(
      resource: ReadableStream | string,
      options: VoiceResourceOptions
    ): void;
    remove(connection: VoiceConnection): void;
    setVolume(volume: number): void;
    stopPlaying(): void;
  }
  declare class VoiceDataStream {
    type: string;
    constructor(type: string): *;
  }
  declare export class VoiceConnectionManager<T: VoiceConnection>
    extends Collection<T> implements SimpleJSON {
    constructor(vcObject: () => T): *;
    join(
      guildID: string,
      channelID: string,
      options: VoiceResourceOptions
    ): Promise<VoiceConnection>;
    leave(guildID: string): void;
    switch(guildID: string, channelID: string): void;
    toJSON(simple?: boolean): JSONCache;
  }
  declare class Base implements SimpleJSON {
    id: string;
    createdAt: number;
    constructor(id: string): *;
    inspect(): *;
    toJSON(simple?: boolean): JSONCache;
  }
  declare export class Bucket {
    tokens: number;
    lastReset: number;
    lastSend: number;
    tokenLimit: number;
    interval: number;
    constructor(
      tokenLimit: number,
      interval: number,
      latencyRef: {
        latency: number
      }
    ): *;
    queue(func: Function): void;
  }
  declare export class Collection<T> extends Map<string | number, T> {
    baseObject: (...args: any[]) => T;
    limit: number;
    constructor(baseObject: (...args: any[]) => T, limit?: number): *;
    add(obj: T, extra?: any, replace?: boolean): T;
    find(func: (i: T) => boolean): T;
    random(): T;
    filter(func: (i: T) => boolean): T[];
    map<R>(func: (i: T) => R): R[];
    update(obj: T, extra?: any, replace?: boolean): T;
    remove(
      obj:
        | T
        | {
            id: string
          }
    ): T;
  }
  declare export class Call extends Base {
    id: string;
    createdAt: number;
    channel: GroupChannel;
    voiceStates: Collection<VoiceState>;
    participants: string[];
    endedTimestamp: number;
    ringing: string[];
    region: string;
    unavailable: boolean;
    constructor(data: BaseData, channel: GroupChannel): *;
  }
  declare export class Channel extends Base {
    id: string;
    mention: string;
    type: number;
    createdAt: number;
    constructor(data: BaseData): *;
  }
  declare export class ExtendedUser extends User {
    email: string;
    verified: boolean;
    mfaEnabled: boolean;
  }
  declare export class GroupChannel extends PrivateChannel {
    recipients: Collection<User>;
    name: string;
    icon: string;
    iconURL: string;
    ownerID: string;
    edit(options: {
      name?: string,
      icon?: string,
      ownerID?: string
    }): Promise<GroupChannel>;
    addRecipient(userID: string): Promise<void>;
    removeRecipient(userID: string): Promise<void>;
    dynamicIconURL(format: string, size: number): string;
  }
  declare export class Guild extends Base {
    id: string;
    createdAt: number;
    name: string;
    verificationLevel: number;
    region: string;
    icon: string;
    afkChannelID: string;
    systemChannelID: string;
    afkTimeout: number;
    defaultNotifications: number;
    mfaLevel: number;
    joinedAt: number;
    ownerID: string;
    splash: string;
    unavailable: boolean;
    large: boolean;
    maxPresences: number;
    channels: Collection<AnyGuildChannel>;
    members: Collection<Member>;
    memberCount: number;
    roles: Collection<Role>;
    shard: Shard;
    features: string[];
    emojis: Emoji[];
    iconURL: string;
    explicitContentFilter: number;
    constructor(data: BaseData, client: Client): *;
    fetchAllMembers(): void;
    dynamicIconURL(format: string, size: number): string;
    createChannel(
      name: string,
      type: string,
      parentID?: string
    ): Promise<AnyGuildChannel>;
    createEmoji(
      options: {
        name: string,
        image: string,
        roles?: string[]
      },
      reason?: string
    ): Promise<EmojiOptions>;
    editEmoji(
      emojiID: string,
      options: {
        name: string,
        roles?: string[]
      },
      reason?: string
    ): Promise<EmojiOptions>;
    deleteEmoji(emojiID: string, reason?: string): Promise<void>;
    createRole(options: RoleOptions, reason?: string): Promise<Role>;
    getPruneCount(days: number): Promise<number>;
    pruneMembers(days: number, reason?: string): Promise<number>;
    getRESTChannels(): Promise<AnyGuildChannel[]>;
    getRESTEmojis(): Promise<Emoji[]>;
    getRESTEmoji(emojiID: string): Promise<Emoji>;
    getRESTMembers(limit?: number, after?: string): Promise<Member[]>;
    getRESTMember(memberID: string): Promise<Member>;
    getRESTRoles(): Promise<Role[]>;
    getEmbed(): Promise<GuildEmbed>;
    getVoiceRegions(): Promise<VoiceRegion[]>;
    leaveVoiceChannel(): void;
    editRole(roleID: string, options: RoleOptions): Promise<Role>;
    deleteRole(roleID: string): Promise<void>;
    getAuditLogs(
      limit?: number,
      before?: string,
      actionType?: number
    ): Promise<GuildAuditLog>;
    getIntegrations(): Promise<GuildIntegration>;
    editIntegration(
      integrationID: string,
      options: IntegrationOptions
    ): Promise<void>;
    syncIntegration(integrationID: string): Promise<void>;
    deleteIntegration(integrationID: string): Promise<void>;
    getInvites(): Promise<Invite[]>;
    editMember(
      memberID: string,
      options: MemberOptions,
      reason?: string
    ): Promise<void>;
    addMemberRole(
      memberID: string,
      roleID: string,
      reason?: string
    ): Promise<void>;
    removeMemberRole(
      memberID: string,
      roleID: string,
      reason?: string
    ): Promise<void>;
    kickMember(userID: string, reason?: string): Promise<void>;
    banMember(
      userID: string,
      deleteMessageDays?: number,
      reason?: string
    ): Promise<void>;
    unbanMember(userID: string, reason?: string): Promise<void>;
    edit(options: GuildOptions, reason?: string): Promise<Guild>;
    delete(): Promise<void>;
    leave(): Promise<void>;
    getBans(): Promise<User[]>;
    editNickname(nick: string): Promise<void>;
    getWebhooks(): Promise<Webhook[]>;
  }
  declare export class GuildAuditLogEntry extends Base {
    id: string;
    guild: Guild;
    actionType: number;
    reason: string;
    user: User;
    targetID: string;
    target: Guild | AnyGuildChannel | Member | Invite | Role | any;
    before: any;
    after: any;
    count: number;
    channel: AnyGuildChannel;
    deleteMemberDays: number;
    membersRemoved: number;
    member: Member | any;
    role: Role | any;
    constructor(data: BaseData, guild: Guild): *;
  }
  declare export class GuildChannel extends Channel {
    guild: Guild;
    parentID: string;
    name: string;
    position: number;
    permissionOverwrites: Collection<PermissionOverwrite>;
    nsfw: boolean;
    constructor(data: BaseData, guild: Guild): *;
    getInvites(): Promise<Invite[]>;
    createInvite(
      options?: CreateInviteOptions,
      reason?: string
    ): Promise<Invite>;
    permissionsOf(memberID: string): Permission;
    edit(
      options: {
        name?: string,
        topic?: string,
        bitrate?: number,
        userLimit?: number,
        nsfw?: boolean
      },
      reason?: string
    ): Promise<AnyGuildChannel>;
    editPosition(position: number): Promise<void>;
    delete(reason?: string): Promise<void>;
    editPermission(
      overwriteID: string,
      allow: number,
      deny: number,
      type: string,
      reason?: string
    ): Promise<PermissionOverwrite>;
    deletePermission(overwriteID: string, reason?: string): Promise<void>;
  }
  declare export class CategoryChannel extends GuildChannel {
    channels: Collection<AnyGuildChannel>;
  }
  declare export class TextChannel extends GuildChannel implements Textable, Invitable {
    topic: string;
    lastMessageID: string;
    messages: Collection<Message>;
    constructor(data: BaseData, guild: Guild, messageLimit: number): *;
    getInvites(): Promise<Invite[]>;
    createInvite(
      options?: CreateInviteOptions,
      reason?: string
    ): Promise<Invite>;
    getWebhooks(): Promise<Webhook[]>;
    createWebhook(
      options: {
        name: string,
        avatar: string
      },
      reason?: string
    ): Promise<Webhook>;
    sendTyping(): Promise<void>;
    getMessage(messageID: string): Promise<Message>;
    getMessages(
      limit?: number,
      before?: string,
      after?: string,
      around?: string
    ): Promise<Message[]>;
    getPins(): Promise<Message[]>;
    createMessage(
      content: MessageContent,
      file?: MessageFile
    ): Promise<Message>;
    editMessage(messageID: string, content: MessageContent): Promise<Message>;
    pinMessage(messageID: string): Promise<void>;
    unpinMessage(messageID: string): Promise<void>;
    getMessageReaction(
      messageID: string,
      reaction: string,
      limit?: number,
      before?: string,
      after?: string
    ): Promise<User[]>;
    addMessageReaction(
      messageID: string,
      reaction: string,
      userID?: string
    ): Promise<void>;
    removeMessageReaction(
      messageID: string,
      reaction: string,
      userID?: string
    ): Promise<void>;
    removeMessageReactions(messageID: string): Promise<void>;
    deleteMessage(messageID: string, reason?: string): Promise<void>;
    unsendMessage(messageID: string): Promise<void>;
  }
  declare export class VoiceChannel extends GuildChannel implements Invitable {
    bitrate: number;
    userLimit: number;
    voiceMembers: Collection<Member>;
    join(options: VoiceResourceOptions): Promise<VoiceConnection>;
    leave(): void;
  }
  declare export class GuildIntegration extends Base {
    id: string;
    createdAt: number;
    name: string;
    type: string;
    roleID: string;
    user: User;
    account: {
      id: string,
      name: string
    };
    enabled: boolean;
    syncing: boolean;
    expireBehavior: number;
    expireGracePeriod: number;
    enableEmoticons: boolean;
    subscriberCount: number;
    syncedAt: number;
    constructor(data: BaseData, guild: Guild): *;
    edit(options: {
      expireBehavior: string,
      expireGracePeriod: string,
      enableEmoticons: string
    }): Promise<void>;
    delete(): Promise<void>;
    sync(): Promise<void>;
  }
  declare export class Invite implements SimpleJSON {
    code: string;
    channel: {
      id: string,
      name: string
    };
    guild: {
      id: string,
      name: string,
      splash?: string,
      icon?: string,
      textChannelCount?: number,
      voiceChannelCount?: number
    };
    inviter: User;
    uses: number;
    maxUses: number;
    maxAge: number;
    temporary: boolean;
    createdAt: number;
    revoked: boolean;
    presenceCount: number;
    memberCount: number;
    constructor(data: BaseData, client: Client): *;
    delete(reason?: string): Promise<void>;
    toJSON(simple?: boolean): JSONCache;
  }
  declare export class Member extends Base {
    id: string;
    mention: string;
    guild: Guild;
    joinedAt: number;
    status: string;
    game: GamePresence;
    voiceState: VoiceState;
    nick: string;
    roles: string[];
    user: User;
    permission: Permission;
    defaultAvatar: string;
    createdAt: number;
    bot: boolean;
    username: string;
    discriminator: string;
    avatar: string;
    defaultAvatarURL: string;
    avatarURL: string;
    staticAvatarURL: string;
    constructor(data: BaseData, guild: Guild): *;
    edit(options: MemberOptions, reason?: string): Promise<void>;
    addRole(roleID: string, reason?: string): Promise<void>;
    removeRole(roleID: string, reason?: string): Promise<void>;
    kick(reason?: string): Promise<void>;
    ban(deleteMessageDays?: number, reason?: string): Promise<void>;
    unban(reason?: string): Promise<void>;
  }
  declare export class Message extends Base {
    id: string;
    createdAt: number;
    channel: TextableChannel;
    timestamp: number;
    type: number;
    author: User;
    member: Member;
    mentions: User[];
    content: string;
    cleanContent: string;
    roleMentions: string[];
    channelMentions: string[];
    editedTimestamp: number;
    tts: boolean;
    mentionEveryone: boolean;
    attachments: Attachment[];
    embeds: Embed[];
    reactions: {
      [s: string]: any,
      count: number,
      me: boolean
    };
    prefix: string;
    command: Command;
    constructor(data: BaseData, client: Client): *;
    edit(content: MessageContent): Promise<Message>;
    pin(): Promise<void>;
    unpin(): Promise<void>;
    getReaction(
      reaction: string,
      limit?: number,
      before?: string,
      after?: string
    ): Promise<User[]>;
    addReaction(reaction: string, userID?: string): Promise<void>;
    removeReaction(reaction: string, userID?: string): Promise<void>;
    removeReactions(): Promise<void>;
    delete(reason?: string): Promise<void>;
  }
  declare export class Permission {
    allow: number;
    deny: number;
    json: {
      [s: string]: boolean
    };
    constructor(allow: number, deny: number): *;
    has(permission: string): boolean;
  }
  declare export class PermissionOverwrite extends Permission {
    id: string;
    createdAt: number;
    type: string;
    constructor(data: {
      allow: number,
      deny: number
    }): *;
  }
  declare export class PrivateChannel extends Channel implements Textable {
    lastMessageID: string;
    recipient: User;
    messages: Collection<Message>;
    ring(recipient: string[]): void;
    syncCall(): void;
    leave(): Promise<void>;
    sendTyping(): Promise<void>;
    getMessage(messageID: string): Promise<Message>;
    getMessages(
      limit?: number,
      before?: string,
      after?: string,
      around?: string
    ): Promise<Message[]>;
    getPins(): Promise<Message[]>;
    createMessage(
      content: MessageContent,
      file?: MessageFile
    ): Promise<Message>;
    editMessage(messageID: string, content: MessageContent): Promise<Message>;
    pinMessage(messageID: string): Promise<void>;
    unpinMessage(messageID: string): Promise<void>;
    getMessageReaction(
      messageID: string,
      reaction: string,
      limit?: number,
      before?: string,
      after?: string
    ): Promise<User[]>;
    addMessageReaction(
      messageID: string,
      reaction: string,
      userID?: string
    ): Promise<void>;
    removeMessageReaction(
      messageID: string,
      reaction: string,
      userID?: string
    ): Promise<void>;
    removeMessageReactions(messageID: string): Promise<void>;
    deleteMessage(messageID: string, reason?: string): Promise<void>;
    unsendMessage(messageID: string): Promise<void>;
  }
  declare export class Relationship {
    id: string;
    user: User;
    type: number;
    status: string;
    game: GamePresence;
    constructor(data: BaseData, client: Client): *;
  }
  declare export class Role extends Base {
    id: string;
    createdAt: number;
    guild: Guild;
    mention: string;
    name: string;
    mentionable: boolean;
    managed: boolean;
    hoist: boolean;
    color: number;
    position: number;
    permissions: Permission;
    json: {
      [s: string]: boolean
    };
    constructor(data: BaseData, guild: Guild): *;
    edit(options: RoleOptions, reason?: string): Promise<Role>;
    editPosition(position: number): Promise<void>;
    delete(reason?: string): Promise<void>;
  }
  declare export class UnavailableGuild extends Base {
    id: string;
    createdAt: number;
    unavailable: boolean;
    shard: Shard;
    constructor(data: BaseData, client: Client): *;
  }
  declare export class User extends Base {
    id: string;
    mention: string;
    defaultAvatar: string;
    createdAt: number;
    bot: boolean;
    username: string;
    discriminator: string;
    avatar: string;
    defaultAvatarURL: string;
    avatarURL: string;
    staticAvatarURL: string;
    constructor(data: BaseData, client: Client): *;
    dynamicAvatarURL(format?: string, size?: number): string;
    getDMChannel(): Promise<PrivateChannel>;
    addRelationship(block?: boolean): Promise<void>;
    removeRelationship(): Promise<void>;
    getProfile(): Promise<UserProfile>;
    editNote(note: string): Promise<void>;
    deleteNote(): Promise<void>;
  }
  declare export class VoiceState extends Base implements NestedJSON {
    id: string;
    createdAt: number;
    sessionID: string;
    channelID: string;
    mute: boolean;
    deaf: boolean;
    suppress: boolean;
    selfMute: boolean;
    selfDeaf: boolean;
    constructor(data: BaseData): *;
    toJSON(arg?: any, cache?: Array<string | any>): JSONCache;
  }
  declare export class Shard extends events$EventEmitter implements SimpleJSON, Emittable {
    id: number;
    connecting: boolean;
    ready: boolean;
    discordServerTrace: string[];
    status: string;
    lastHeartbeatReceived: number;
    lastHeartbeatSent: number;
    latency: number;
    constructor(id: number, client: Client): *;
    connect(): void;
    disconnect(options?: {
      reconnect: boolean
    }): void;
    editAFK(afk: boolean): void;
    editStatus(status?: string, game?: GamePresence): void;
    on(event: string, listener: Function): *;
    on(event: "ready" | "disconnect", listener: () => void): *;
    on(
      event: "callCreate" | "callRing" | "callDelete",
      listener: (call: Call) => void
    ): *;
    on(
      event: "callUpdate",
      listener: (call: Call, oldCall: OldCall) => void
    ): *;
    on(
      event: "channelCreate" | "channelDelete",
      listener: (channel: AnyChannel) => void
    ): *;
    on(
      event: "channelPinUpdate",
      listener: (
        channel: TextableChannel,
        timestamp: number,
        oldTimestamp: number
      ) => void
    ): *;
    on(
      event: "channelRecipientAdd" | "channelRecipientRemove",
      listener: (channel: GroupChannel, user: User) => void
    ): *;
    on(
      event: "channelUpdate",
      listener: (channel: AnyChannel, oldChannel: OldChannel) => void
    ): *;
    on(
      event: "friendSuggestionCreate",
      listener: (user: User, reasons: FriendSuggestionReasons) => void
    ): *;
    on(event: "friendSuggestionDelete", listener: (user: User) => void): *;
    on(
      event: "guildAvailable" | "guildBanAdd" | "guildBanRemove",
      listener: (guild: Guild, user: User) => void
    ): *;
    on(
      event: "guildDelete" | "guildUnavailable" | "guildCreate",
      listener: (guild: Guild) => void
    ): *;
    on(
      event: "guildEmojisUpdate",
      listener: (guild: Guild, emojis: Emoji[], oldEmojis: Emoji[]) => void
    ): *;
    on(
      event: "guildMemberAdd",
      listener: (guild: Guild, member: Member) => void
    ): *;
    on(
      event: "guildMemberChunk",
      listener: (guild: Guild, members: Member[]) => void
    ): *;
    on(
      event: "guildMemberRemove",
      listener: (guild: Guild, member: Member | MemberPartial) => void
    ): *;
    on(
      event: "guildMemberUpdate",
      listener: (
        guild: Guild,
        member: Member,
        oldMember: {
          roles: string[],
          nick?: string
        }
      ) => void
    ): *;
    on(
      event: "guildRoleCreate" | "guildRoleDelete",
      listener: (guild: Guild, role: Role) => void
    ): *;
    on(
      event: "guildRoleUpdate",
      listener: (guild: Guild, role: Role, oldRole: RoleOptions) => void
    ): *;
    on(
      event: "guildUpdate",
      listener: (guild: Guild, oldGuild: GuildOptions) => void
    ): *;
    on(event: "hello", listener: (trace: string[], id: number) => void): *;
    on(event: "messageCreate", listener: (message: Message) => void): *;
    on(
      event: "messageDelete" | "messageReactionRemoveAll",
      listener: (message: PossiblyUncachedMessage) => void
    ): *;
    on(
      event: "messageDeleteBulk",
      listener: (messages: PossiblyUncachedMessage[]) => void
    ): *;
    on(
      event: "messageReactionAdd" | "messageReactionRemove",
      listener: (
        message: PossiblyUncachedMessage,
        emoji: Emoji,
        userID: string
      ) => void
    ): *;
    on(
      event: "messageUpdate",
      listener: (
        message: Message,
        oldMessage?: {
          attachments: Attachment[],
          embeds: Embed[],
          content: string,
          editedTimestamp?: number,
          mentionedBy?: any,
          tts: boolean,
          mentions: string[],
          roleMentions: string[],
          channelMentions: string[]
        }
      ) => void
    ): *;
    on(
      event: "presenceUpdate",
      listener: (
        other: Member | Relationship,
        oldPresence?: OldPresence
      ) => void
    ): *;
    on(
      event: "rawWS" | "unknown",
      listener: (packet: RawPacket, id: number) => void
    ): *;
    on(
      event: "relationshipAdd" | "relationshipRemove",
      listener: (relationship: Relationship) => void
    ): *;
    on(
      event: "relationshipUpdate",
      listener: (
        relationship: Relationship,
        oldRelationship: {
          type: number
        }
      ) => void
    ): *;
    on(
      event: "shardPreReady" | "connect",
      listener: (id: number) => void
    ): *;
    on(
      event: "typingStart",
      listener: (channel: TextableChannel, user: User) => void
    ): *;
    on(
      event: "unavailableGuildCreate",
      listener: (guild: UnavailableGuild) => void
    ): *;
    on(
      event: "userUpdate",
      listener: (
        user: User,
        oldUser: {
          username: string,
          discriminator: string,
          avatar?: string
        }
      ) => void
    ): *;
    on(
      event: "voiceChannelJoin",
      listener: (member: Member, newChannel: VoiceChannel) => void
    ): *;
    on(
      event: "voiceChannelLeave",
      listener: (member: Member, oldChannel: VoiceChannel) => void
    ): *;
    on(
      event: "voiceChannelSwitch",
      listener: (
        member: Member,
        newChannel: VoiceChannel,
        oldChannel: VoiceChannel
      ) => void
    ): *;
    on(
      event: "voiceStateUpdate",
      listener: (member: Member, oldState: OldVoiceState) => void
    ): *;
    on(
      event: "warn" | "debug",
      listener: (message: string, id: number) => void
    ): *;
    on(event: "disconnect", listener: (err: Error) => void): *;
    on(event: "resume", listener: () => void): *;
    toJSON(simple?: boolean): JSONCache;
    sendWS(op: number, _data: { [key: string]: any }): void;
  }
  declare export class Command {
    subcommands: {
      [s: string]: Command
    };
    constructor(
      label: string,
      generate: CommandGenerator,
      options?: CommandOptions
    ): *;
    registerSubcommandAlias(alias: string, label: string): void;
    registerSubcommand(
      label: string,
      generator: CommandGenerator,
      options?: CommandOptions
    ): void;
    unregisterSubcommand(label: string): void;
  }
  declare export class CommandClient extends Client {
    commands: {
      [s: string]: Command
    };
    constructor(
      token: string,
      options?: ClientOptions,
      commandOptions?: CommandClientOptions
    ): *;
    onMessageCreate(msg: Message): void;
    registerGuildPrefix(guildID: string, prefix: string[] | string): void;
    registerCommandAlias(alias: string, label: string): void;
    registerCommand(
      label: string,
      generator: CommandGenerator,
      options?: CommandOptions
    ): Command;
    unregisterCommand(label: string): void;
  }
}
